Price handles product pricing. Price module also provides plugins for products to populate prices. 
Prices are added to abstract and concrete products. The price is stored as an integer, in the smallest unit of the currency. Each price is assigned to a price type. Each product can have one or many prices with different price types.

Latest version: **5.6.0**
Last update: **27 Sep 2019**

## Dependencies:

* **PHP** >=7.1
* **[Kernel](kernel-spryker-module)** ^3.30.0
* **[PriceExtension](price-extension-spryker-module)** ^1.0.0
* **[Quote](quote-spryker-module)** ^1.2.0 || ^2.0.0
* **[QuoteExtension](quote-extension-spryker-module)** ^1.4.0
* **[Symfony](symfony-spryker-module)** ^3.0.0

## Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.
* **[Twig](twig-spryker-module)** If you want to use twig extension plugins

## Previous Versions

<details>
<summary>5.5.0</summary>

### Dependencies:

* **PHP** >=7.1
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[PriceExtension](price-extension-spryker-module)** ^1.0.0
* **[Quote](quote-spryker-module)** ^1.2.0 || ^2.0.0
* **[QuoteExtension](quote-extension-spryker-module)** ^1.4.0
* **[Symfony](symfony-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.
* **[Twig](twig-spryker-module)** If you want to use twig extension plugins

</details>


<details>
<summary>5.4.1</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceMode</b></td>
            <td><ul><li><p>Returns default price mode as configured in store</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns net price mode identifier</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns gross price mode identifier</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Clients
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getCurrentPriceMode</b></td>
            <td><ul><li><p>Returns current selected price mode as stored in quote</p></li>
<li><p>If its not yet set then uses default price mode as defined in environment configuration</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>switchPriceMode</b></td>
            <td><ul><li><p>Checks if price mode is acceptable.</p></li>
<li><p>Set price mode to quote.</p></li>
<li><p>Call price mode update plugins.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for gross price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for net price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **PHP** >=7.1
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[PriceExtension](price-extension-spryker-module)** ^1.0.0
* **[Quote](quote-spryker-module)** ^1.2.0 || ^2.0.0
* **[Symfony](symfony-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.
* **[Twig](twig-spryker-module)** If you want to use twig extension plugins

</details>


<details>
<summary>5.4.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceMode</b></td>
            <td><ul><li><p>Returns default price mode as configured in store</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns net price mode identifier</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns gross price mode identifier</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Clients
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getCurrentPriceMode</b></td>
            <td><ul><li><p>Returns current selected price mode as stored in quote</p></li>
<li><p>If its not yet set then uses default price mode as defined in environment configuration</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>switchPriceMode</b></td>
            <td><ul><li><p>Checks if price mode is acceptable.</p></li>
<li><p>Set price mode to quote.</p></li>
<li><p>Call price mode update plugins.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for gross price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for net price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **PHP** >=7.1
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[PriceExtension](price-extension-spryker-module)** ^1.0.0
* **[Quote](quote-spryker-module)** ^1.2.0 || ^2.0.0
* **[Symfony](symfony-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.
* **[Twig](twig-spryker-module)** If you want to use twig extension plugins

</details>


<details>
<summary>5.3.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceMode</b></td>
            <td><ul><li><p>Returns default price mode as configured in store</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns net price mode identifier</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns gross price mode identifier</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Clients
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getCurrentPriceMode</b></td>
            <td><ul><li><p>Returns current selected price mode as stored in quote</p></li>
<li><p>If its not yet set then uses default price mode as defined in environment configuration</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>switchPriceMode</b></td>
            <td><ul><li><p>Checks if price mode is acceptable.</p></li>
<li><p>Set price mode to quote.</p></li>
<li><p>Call price mode update plugins.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for gross price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for net price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **PHP** >=7.1
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[PriceExtension](price-extension-spryker-module)** ^1.0.0
* **[Quote](quote-spryker-module)** ^1.2.0 || ^2.0.0
* **[Symfony](symfony-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.
* **[Twig](twig-spryker-module)** If you want to use twig extension plugins

</details>


<details>
<summary>5.2.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceMode</b></td>
            <td><ul><li><p>Returns default price mode as configured in store</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns net price mode identifier</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns gross price mode identifier</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Clients
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getCurrentPriceMode</b></td>
            <td><ul><li><p>Returns current selected price mode as stored in quote</p></li>
<li><p>If its not yet set then uses default price mode as defined in environment configuration</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for gross price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for net price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **PHP** >=7.1
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[Quote](quote-spryker-module)** ^1.2.0 || ^2.0.0
* **[Symfony](symfony-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.
* **[Twig](twig-spryker-module)** If you want to use twig extension plugins

</details>


<details>
<summary>5.1.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceMode</b></td>
            <td><ul><li><p>Returns default price mode as configured in store</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns net price mode identifier</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns gross price mode identifier</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Clients
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getCurrentPriceMode</b></td>
            <td><ul><li><p>Returns current selected price mode as stored in quote</p></li>
<li><p>If its not yet set then uses default price mode as defined in environment configuration</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for gross price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for net price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[Quote](quote-spryker-module)** ^1.0.0
* **[Symfony](symfony-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.
* **[Twig](twig-spryker-module)** If you want to use twig extension plugins

</details>


<details>
<summary>5.0.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceModes</b></td>
            <td><ul><li><p>Returns all available price modes</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceMode</b></td>
            <td><ul><li><p>Returns default price mode as configured in store</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns net price mode identifier</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Returns gross price mode identifier</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Clients
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getCurrentPriceMode</b></td>
            <td><ul><li><p>Returns current selected price mode as stored in quote</p></li>
<li><p>If its not yet set then uses default price mode as defined in environment configuration</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getGrossPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for gross price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getNetPriceModeIdentifier</b></td>
            <td><ul><li><p>Return identifier for net price mode pricing. Same identifier is used when persisting prices</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[Quote](quote-spryker-module)** ^1.0.0
* **[Symfony](symfony-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.
* **[Twig](twig-spryker-module)** If you want to use twig extension plugins

</details>


<details>
<summary>4.3.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPriceCollection</b></td>
            <td><ul><li><p>Create new product price entities if they doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of product price entities if they exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePriceCollection</b></td>
            <td><ul><li><p>Create new product price entities if they doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of product price entities if they exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findPricesBySku</b></td>
            <td><ul><li><p>Reads abstract and concrete product prices from database.</p></li>
<li><p>Concrete prices overwrites abstracts for matching price types.</p></li>
<li><p>The provided SKU can represent both abstract or concrete product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrices</b></td>
            <td><ul><li><p>Reads abstract product prices from database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrices</b></td>
            <td><ul><li><p>Reads abstract and concrete product prices from database.</p></li>
<li><p>Concrete prices overwrites abstracts for matching price types.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Config](config-spryker-module)** ^3.0.0
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[Product](product-spryker-module)** ^5.0.0
* **[PropelOrm](propel-orm-spryker-module)** ^1.0.0
* **[Touch](touch-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.

</details>


<details>
<summary>4.2.3</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPriceCollection</b></td>
            <td><ul><li><p>Create new product price entities if they doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of product price entities if they exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePriceCollection</b></td>
            <td><ul><li><p>Create new product price entities if they doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of product price entities if they exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findPricesBySku</b></td>
            <td><ul><li><p>Reads abstract and concrete product prices from database.</p></li>
<li><p>Concrete prices overwrites abstracts for matching price types.</p></li>
<li><p>The provided SKU can represent both abstract or concrete product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrices</b></td>
            <td><ul><li><p>Reads abstract product prices from database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrices</b></td>
            <td><ul><li><p>Reads abstract and concrete product prices from database.</p></li>
<li><p>Concrete prices overwrites abstracts for matching price types.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Config](config-spryker-module)** ^3.0.0
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[Product](product-spryker-module)** ^5.0.0
* **[PropelOrm](propel-orm-spryker-module)** ^1.0.0
* **[Touch](touch-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.

</details>


<details>
<summary>4.2.2</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPriceCollection</b></td>
            <td><ul><li><p>Create new product price entities if they doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of product price entities if they exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePriceCollection</b></td>
            <td><ul><li><p>Create new product price entities if they doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of product price entities if they exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findPricesBySku</b></td>
            <td><ul><li><p>Reads abstract and concrete product prices from database.</p></li>
<li><p>Concrete prices overwrites abstracts for matching price types.</p></li>
<li><p>The provided SKU can represent both abstract or concrete product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrices</b></td>
            <td><ul><li><p>Reads abstract product prices from database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrices</b></td>
            <td><ul><li><p>Reads abstract and concrete product prices from database.</p></li>
<li><p>Concrete prices overwrites abstracts for matching price types.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Config](config-spryker-module)** ^3.0.0
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[Product](product-spryker-module)** ^5.0.0
* **[PropelOrm](propel-orm-spryker-module)** ^1.0.0
* **[Touch](touch-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.

</details>


<details>
<summary>4.2.1</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPriceCollection</b></td>
            <td><ul><li><p>Create new product price entities if they doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of product price entities if they exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePriceCollection</b></td>
            <td><ul><li><p>Create new product price entities if they doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of product price entities if they exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findPricesBySku</b></td>
            <td><ul><li><p>Reads abstract and concrete product prices from database.</p></li>
<li><p>Concrete prices overwrites abstracts for matching price types.</p></li>
<li><p>The provided SKU can represent both abstract or concrete product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrices</b></td>
            <td><ul><li><p>Reads abstract product prices from database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrices</b></td>
            <td><ul><li><p>Reads abstract and concrete product prices from database.</p></li>
<li><p>Concrete prices overwrites abstracts for matching price types.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Config](config-spryker-module)** ^3.0.0
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[Product](product-spryker-module)** ^5.0.0
* **[PropelOrm](propel-orm-spryker-module)** ^1.0.0
* **[Touch](touch-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider.

</details>


<details>
<summary>4.2.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPriceCollection</b></td>
            <td><ul><li><p>Create new product price entities if they doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of product price entities if they exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePriceCollection</b></td>
            <td><ul><li><p>Create new product price entities if they doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of product price entities if they exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findPricesBySku</b></td>
            <td><ul><li><p>Reads abstract and concrete product prices from database.</p></li>
<li><p>Concrete prices overwrites abstracts for matching price types.</p></li>
<li><p>The provided SKU can represent both abstract or concrete product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrices</b></td>
            <td><ul><li><p>Reads abstract product prices from database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrices</b></td>
            <td><ul><li><p>Reads abstract and concrete product prices from database.</p></li>
<li><p>Concrete prices overwrites abstracts for matching price types.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Config](config-spryker-module)** ^3.0.0
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[Product](product-spryker-module)** ^5.0.0
* **[PropelOrm](propel-orm-spryker-module)** ^1.0.0
* **[Touch](touch-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins you need to install spryker/installer.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider you need to install spryker/silex

</details>


<details>
<summary>4.1.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Config](config-spryker-module)** ^3.0.0
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[Product](product-spryker-module)** ^5.0.0
* **[PropelOrm](propel-orm-spryker-module)** ^1.0.0
* **[Touch](touch-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins you need to install spryker/installer.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider you need to install spryker/silex

</details>


<details>
<summary>4.0.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Config](config-spryker-module)** ^3.0.0
* **[Kernel](kernel-spryker-module)** ^3.0.0
* **[Product](product-spryker-module)** ^5.0.0
* **[PropelOrm](propel-orm-spryker-module)** ^1.0.0
* **[Touch](touch-spryker-module)** ^3.0.0

### Suggested Installations:

* **[Installer](installer-spryker-module)** If you want to use Installer plugins you need to install spryker/installer.
* **[Silex](silex-spryker-module)** If you want to use ServiceProvider you need to install spryker/silex

</details>


<details>
<summary>3.0.3</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Application](application-spryker-module)** ^2.0.0
* **[Config](config-spryker-module)** ^2.0.0
* **[Installer](installer-spryker-module)** ^2.0.0 || ^3.0.0
* **[Kernel](kernel-spryker-module)** ^2.0.0
* **[Library](library-spryker-module)** ^2.0.0
* **[Messenger](messenger-spryker-module)** ^2.0.0
* **[Product](product-spryker-module)** ^4.0.0
* **[Propel](propel-spryker-module)** ^2.0.0
* **[Silex](silex-spryker-module)** ^2.0.0
* **[Touch](touch-spryker-module)** ^2.0.0
* **[Twig](twig-spryker-module)** ^2.1.0

</details>


<details>
<summary>3.0.2</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Application](application-spryker-module)** ^2.0.0
* **[Config](config-spryker-module)** ^2.0.0
* **[Installer](installer-spryker-module)** ^2.0.0 || ^3.0.0
* **[Kernel](kernel-spryker-module)** ^2.0.0
* **[Library](library-spryker-module)** ^2.0.0
* **[Messenger](messenger-spryker-module)** ^2.0.0
* **[Product](product-spryker-module)** ^4.0.0
* **[Propel](propel-spryker-module)** ^2.0.0
* **[Silex](silex-spryker-module)** ^2.0.0
* **[Touch](touch-spryker-module)** ^2.0.0
* **[Twig](twig-spryker-module)** ^2.1.0

</details>


<details>
<summary>3.0.1</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Application](application-spryker-module)** ^2.0.0
* **[Config](config-spryker-module)** ^2.0.0
* **[Installer](installer-spryker-module)** ^2.0.0 || ^3.0.0
* **[Kernel](kernel-spryker-module)** ^2.0.0
* **[Library](library-spryker-module)** ^2.0.0
* **[Messenger](messenger-spryker-module)** ^2.0.0
* **[Product](product-spryker-module)** ^4.0.0
* **[Propel](propel-spryker-module)** ^2.0.0
* **[Silex](silex-spryker-module)** ^2.0.0
* **[Touch](touch-spryker-module)** ^2.0.0
* **[Twig](twig-spryker-module)** ^2.1.0

</details>


<details>
<summary>3.0.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td><ul><li><p>Reads all persisted price types and returns their names in an array.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductAbstractPrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given abstract product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if the price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>findProductConcretePrice</b></td>
            <td><ul><li><p>Reads the persisted price for the given concrete product id for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>If the price is not found, then it'll read the abstract product price instead.</p></li>
<li><p>Returns a hydrated PriceProductTransfer if one of the concrete or abstract price exists, null otherwise.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td><ul><li><p>Creates a new price type entity and persists it in database.</p></li>
<li><p>Returns the ID of the persisted type.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td><ul><li><p>Updates existing product price entity with the newly provided data.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product doesn't have price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td><ul><li><p>Creates the default price type from configuration and persists it in database.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td><ul><li><p>Searches for a persisted price in database that has the given SKU for the given price type.</p></li>
<li><p>If price type is not provided, then the default price type will be used.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price of the</p>
<p>abstract product will be checked instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td><ul><li><p>Creates and assigns a new price product entity for the given product.</p></li>
<li><p>If the price type is not defined, then the default price type will be used.</p></li>
<li><p>The product to assign can be either concrete or abstract, depending on the provided IDs.</p></li>
<li><p>If the product already has price, it throws exception.</p></li>
<li><p>Touches product.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td><ul><li><p>Returns the default price type name from configuration.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td><ul><li><p>Searches for a persisted price ID in database that has the given SKU for the given price type.</p></li>
<li><p>The SKU can belong to either a concrete or an abstract product.</p></li>
<li><p>If it's a concrete product's SKU and it doesn't have any price assigned explicitly, then the price ID of the</p>
<p>abstract product will be returned instead.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductAbstractPrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by abstract product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by abstract product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
        <tr>
            <td><b>persistProductConcretePrice</b></td>
            <td><ul><li><p>Create a new product price entity if it doesn't exists by concrete product id and price type.</p></li>
<li><p>Updates the price of a product price entity if it exists by concrete product id and price type.</p></li>
<li><p>If price type wasn't explicitly specified, then the default price type will be used.</p></li></ul>
</td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Application](application-spryker-module)** ^2.0.0
* **[Config](config-spryker-module)** ^2.0.0
* **[Installer](installer-spryker-module)** ^2.0.0 || ^3.0.0
* **[Kernel](kernel-spryker-module)** ^2.0.0
* **[Library](library-spryker-module)** ^2.0.0
* **[Messenger](messenger-spryker-module)** ^2.0.0
* **[Product](product-spryker-module)** 4.0.0
* **[Propel](propel-spryker-module)** ^2.0.0
* **[Silex](silex-spryker-module)** ^2.0.0
* **[Touch](touch-spryker-module)** ^2.0.0
* **[Twig](twig-spryker-module)** ^2.1.0

</details>


<details>
<summary>2.0.2</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td></td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Application](application-spryker-module)** ^2.0.0
* **[Config](config-spryker-module)** ^2.0.0
* **[Installer](installer-spryker-module)** ^2.0.0 || ^3.0.0
* **[Kernel](kernel-spryker-module)** ^2.0.0
* **[Library](library-spryker-module)** ^2.0.0
* **[Messenger](messenger-spryker-module)** ^2.0.0
* **[Product](product-spryker-module)** ^2.0.0 || ^3.0.0
* **[Silex](silex-spryker-module)** ^2.0.0
* **[Touch](touch-spryker-module)** ^2.0.0
* **[Twig](twig-spryker-module)** ^2.1.0

</details>


<details>
<summary>2.0.1</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td></td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Application](application-spryker-module)** ^2.0.0
* **[Config](config-spryker-module)** ^2.0.0
* **[Installer](installer-spryker-module)** ^2.0.0 || ^3.0.0
* **[Kernel](kernel-spryker-module)** ^2.0.0
* **[Library](library-spryker-module)** ^2.0.0
* **[Messenger](messenger-spryker-module)** ^2.0.0
* **[Product](product-spryker-module)** ^2.0.0
* **[Silex](silex-spryker-module)** ^2.0.0
* **[Touch](touch-spryker-module)** ^2.0.0
* **[Twig](twig-spryker-module)** ^2.0.0

</details>


<details>
<summary>2.0.0</summary>

### API (Facades)
<table>
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>getPriceTypeValues</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>getPriceBySku</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>createPriceType</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>setPriceForProduct</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>install</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>hasValidPrice</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>createPriceForProduct</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>getDefaultPriceTypeName</b></td>
            <td></td>
        </tr>
        <tr>
            <td><b>getIdPriceProduct</b></td>
            <td></td>
        </tr>
    </tbody>
</table>

### Dependencies:

* **[Application](application-spryker-module)** ^2.0.0
* **[Installer](installer-spryker-module)** ^2.0.0
* **[Kernel](kernel-spryker-module)** ^2.0.0
* **[Library](library-spryker-module)** ^2.0.0
* **[Messenger](messenger-spryker-module)** ^2.0.0
* **[Product](product-spryker-module)** ^2.0.0
* **[Touch](touch-spryker-module)** ^2.0.0
* **[Twig](twig-spryker-module)** ^2.0.0
* **[Config](config-spryker-module)** ^2.0.0
* **[Silex](silex-spryker-module)** ^2.0.0

</details>

